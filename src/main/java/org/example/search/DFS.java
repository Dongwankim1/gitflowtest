package org.example.search;

import java.util.ArrayList;

/**
 * packageName    : org.example.array
 * fileName       : DFS
 * author         : mac
 * date           : 10/22/24
 * description    :
 * ===========================================================
 * DATE              AUTHOR             NOTE
 * -----------------------------------------------------------
 * 10/22/24        mac       최초 생성
 */
//시간복잡도 O(V+E)
    //V: 노드 , E: 에지
    //DFS는 트리 완전 탐색을 할때 사용한다
//재귀 함수로 구현 , 스택 자료구조 이용
    //깊은 우선 탐색
//자료구조는 인접리스트 사용해야한다.
    //방문 배열을 사용해야한다.
    //1 -> 2,3
    //2 -> 5,6
    //3 -> 4
    //4 -> 6
    //5 ->
    //6 ->
    // 1 -> 3 -> 4 -> 6 -> 2-> 5

/**
 * 완전탐색: DFS는 특정 문제에서 가능한 모든 경로를 탐색해야 하는 경우에 유용합니다. 예를 들어, 미로 찾기, 경로 찾기, 게임판 탐색 등의 문제에서 DFS를 사용하면 가능한 모든 경로를 효율적으로 탐색할 수 있습니다.
 *
 * 백트래킹: DFS는 백트래킹 알고리즘의 핵심입니다. 특정 경로를 선택하고, 더 이상 탐색이 불가능하거나 조건에 맞지 않으면 해당 경로를 되돌아가 다른 경로를 탐색하는 방식으로 작동합니다. 이를 통해 최적의 해를 찾거나, 불가능한 경로를 제외할 수 있습니다.
 *
 * 경로 찾기: DFS는 특정 노드에서 목표 노드까지의 경로를 찾는 데 자주 사용됩니다. 경로를 탐색하는 과정에서 먼저 한 방향으로 깊게 탐색하기 때문에 목적지에 도달했을 때 경로가 자연스럽게 기록됩니다.
 *
 * 사이클 검출: DFS는 방향 그래프나 무방향 그래프에서 사이클을 검출하는 데도 유용합니다. 탐색 중에 이미 방문한 노드를 다시 방문하면 사이클이 존재한다는 것을 알 수 있습니다.
 *
 * 위상 정렬: DFS는 위상 정렬을 구현하는 데도 사용됩니다. 방향성이 있는 그래프에서 순서를 결정해야 할 때, DFS를 이용해 노드의 종료 시간을 기록하고 이를 역순으로 정렬하는 방식으로 위상 정렬을 수행할 수 있습니다.
 */
public class DFS {
    /**
     * 한번 방문한 노드를 다시 방문하면 안되므로 노드 방문 여부를 체크할 배열이 필요
     * 모든 노드를 탐색하는 수가 = 연결 요소 개수
     * DFS가 총 2회 실행 됬다면 , 연결 요수 개수는 2개이다.
     */

    public static void main(String[] args) {

        ArrayList<Integer>[] dfsList = new ArrayList[5];
    }
}
